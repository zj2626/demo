硬件优化：
    1.cpu
    2.内存
    3.I/O
    4.网络
存储引擎优化：
    1.innoDB
    2.MyISAM
存储引擎优化：
    1.I/O
    2.缓存
表设计优化
    1.表存储引擎选择：事务型选择InnoDB，非事务型选择MyISAM
    2.表压缩选择：压缩的表IO少
    3.第三范式：更新类应用尽量符合第三范式，分析类应用反之
    4.数据物理分布策略：尽量让表数据分布在不同的物理设备，用表空间技术把数据分散
    5.数据逻辑分布策略：利用分区技术把数据从逻辑上分开
    6.数据类型选择：
        数字类型优于字符类型
        长度小的优于长度大的
        变长的varchar优于定长的char
        用binary varchar替代blob类型，不能替代的单独表存放，原表存放其md5后值用于比较（blob一般不存放数据库）
    7.使用完整性约束：使用not null标识字段，设置default value（mysql使用not null完成语义优化）；
    8.列名不超过18个字符，定义字符集时候尽量使用占用空间少的字符集（utf-8占用空间是latin1的3倍）

InnoDB优化：
    1.单表容量优化：(定期对表的数据进行整理) optimize table statement to reorganized the table and compact any wasted space
    2.单表统计数据优化：analyze table tpch.customer
    3.启用压缩
    4.尽量使用短事务
    5.事务管理：
        1.写操作多：批量提交事务
        2.读事务多：设置自动提交
    6.加大日志文件和日志缓存（innodb_log_file_size, innodb_log_buffer_size）
    7.主键最好使用最常用的列作为主键
    8.主键列不要太长
    9.建立有效的索引：尽量建立联合索引而不是多个列上建立各自的
    10.删除数据释放表空间：使用truncate table
    11.数据刷出方式

库级优化：
    1.同一个库中表不要太多（table_open_cache, max_connections）
    2.启用查好像缓存（query_cache_type, query_cache_size）
    3.使用长连接，连接池
    4.使用主从架构，主写从读

数据库获取方式
    1.一次获取数据尽可能少，where条件精确获取范围且要有索引，要减少连接操纵，并且不能有全表扫描
        少 准 快 少关联
    2.不用select *，要指定列名
    3.使用limit限制元组个数
利用索引优化
    1.正确使用索引：每个查询语句都用explain验证
    2.索引列不参与运算
    3.精确化查找条件：单表不全表扫描，多表尽量；加where；where加索引
    4.等式/不等式人工推理优化
    5.求最值/总数的列建立索引
    6.分组/排序/去重的列建立索引
    7.建立主外键关系
    8.引入合适的新列方便查询
    9.存在范围查找时，尽量建立btree索引
    10：索引：尽量使用主键索引/唯一索引
    11.创建索引：索引的键值类型越短越好（数值型列比较短，适合创建索引）
    12.少建索引：不要建立没用的索引，尽量用联合索引
    13.删除索引：删除少用的索引
    14.只读索引（covering indexes）：覆盖索引，查询语句出现的对象尽量限制在单个索引中的全部列中，减少io操作
    15.前缀索引：尽量使用索引的前缀部分
    16.通配符：不要把通配符放在前面
    17.强制索引：特殊情况下强制使用指定索引

数据库监控-调优使用：
    1.show status;
    2.show status like 'handler_read%';
    3.show status like 'Table%';
    4.show status like 'Slow%';
    5.show status like 'Up%';
    5.show variables like '%slow%'; 查看慢查询是否开启
定位问题：
    1.检查索引是否被使用
    2.检查索引是否用的对
    3.检查索引是否参与了计算
    4.检查不同索引之间在where/on/having条件下的选择率，高于10%就应该查找原因或者禁用此索引
    5.检查索引使用方式，看只读索引是否可行
    6.检查出现分组/排序/去重时候索引使用情况
