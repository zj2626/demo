---
title: 垃圾收集器与内存分配策略

comments: true    

tags: 
    - 深入了解java虚拟机
    - java

categories: 
    - java虚拟机

description: 

---

## 1. 垃圾收集 (Garbage Collection,GC)

Java内存 运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随 线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个 栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器 进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此 这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问 题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也 可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配 和回收都是动态的，垃圾收集器所关注的是这部分内存

## 2.判断对象是否存活算法
    1.　引用计数算法 
    
    给对象中添加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；
    任何时刻计数器为0 的对象就是不可能再被使用的。
#### 优点:实现简单，判定效率很高    
#### 缺点:很难解决对象 之间相互循环引用的问题。
    2.　可达性分析算法  (在主流的商用程序语言（Java、C#...中实现)
    
    这个算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所 走过的路径称为引用链（Reference Chain），
    当一个对象到GC Roots没有任何引用链相连 （用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

```text
在Java语言中，可作为GC Roots的对象包括下面几种：
    虚拟机栈（栈帧中的本地变量表）中引用的对象。 
    方法区中类静态属性引用的对象。 
    方法区中常量引用的对象。 
    本地方法栈中JNI（即一般说的Native方法）引用的对
```



## 3.关于引用

> 传统定义:：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块 内存代表着一个引用。

> 当前的扩充定义: 引用分为4种
```text
    1. 强引用: 通过new出来的, 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
    2. 软引用: 用来描述一些还有用但并非必需的对象
        对于软引用关联着的对象，在系统将 要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。
        在JDK 1.2之后，提供了SoftReference类来实 现软引用。 
    3. 弱引用: 用来描述非必需的对象 更弱
```



#### 1. 对象回收

> 1. 对于通过可达性分析算法得到的不可达的对象进行回收, 但不是直接回收, 会经历两次标记
> 2. 先对可达性分析算法之后不可达的对象进行第一次标记, 并对对象筛选是否需要调用finalize方法(两种情况不需要执行: 1.已经调用过一次finalize; 2.对象没有覆盖finalize方法)
> 3. 对于需要执行finalize方法情况, 该对象会被放到F-Queue队列中, 等到另一个低优先级的线程(Finalizer)去执行各个对象的finalize方法, 在finalize方法中可以把自己重新加入引用链中逃脱本次回收(但是下次回收不会再执行一次finalize方法了)
> 4. 稍后进行第二次标记, 然后进行回收

#### 2. 方法区回收

>  	1. 常量池回收: 系统没有一个对象引用了该字面量
>  	2. 类回收: 1.类所有实例都已被回收(没一个类的对象); 2.类的ClassLoader已经被回收; 3.类的Class对象没有被引用,没有通过反射获取的
