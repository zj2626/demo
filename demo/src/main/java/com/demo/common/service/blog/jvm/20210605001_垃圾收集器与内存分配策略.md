---
title: 垃圾收集器与内存分配策略

comments: true    

tags: 
    - 深入了解java虚拟机
    - java

categories: 
    - java虚拟机

description: 

---

## 1. 垃圾收集 (Garbage Collection,GC)

Java内存 运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随 线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个 栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器 进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此 这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问 题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也 可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配 和回收都是动态的，垃圾收集器所关注的是这部分内存

## 2.判断对象是否存活算法
    1.　引用计数算法 
    
    给对象中添加一个引用计数器，每当有 一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；
    任何时刻计数器为0 的对象就是不可能再被使用的。
#### 优点:实现简单，判定效率很高    
#### 缺点:很难解决对象 之间相互循环引用的问题。
    2.　可达性分析算法  (在主流的商用程序语言（Java、C#...中实现)
    
    这个算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所 走过的路径称为引用链（Reference Chain），
    当一个对象到GC Roots没有任何引用链相连 （用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的

```text
在Java语言中，可作为GC Roots的对象包括下面几种：
    虚拟机栈（栈帧中的本地变量表）中引用的对象。 
    方法区中类静态属性引用的对象。 
    方法区中常量引用的对象。 
    本地方法栈中JNI（即一般说的Native方法）引用的对
```



## 3.关于引用

> 传统定义:：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块 内存代表着一个引用。

> 当前的扩充定义: 引用分为4种
```text
    1. 强引用: 通过new出来的, 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
    2. 软引用: 用来描述一些还有用但并非必需的对象
        对于软引用关联着的对象，在系统将 要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。
        在JDK 1.2之后，提供了SoftReference类来实 现软引用。 
    3. 弱引用: 用来描述非必需的对象 更弱
```



#### 1. 对象回收

> 1. 对于通过可达性分析算法得到的不可达的对象进行回收, 但不是直接回收, 会经历两次标记
> 2. 先对可达性分析算法之后不可达的对象进行第一次标记, 并对对象筛选是否需要调用finalize方法(两种情况不需要执行: 1.已经调用过一次finalize; 2.对象没有覆盖finalize方法)
> 3. 对于需要执行finalize方法情况, 该对象会被放到F-Queue队列中, 等到另一个低优先级的线程(Finalizer)去执行各个对象的finalize方法, 在finalize方法中可以把自己重新加入引用链中逃脱本次回收(但是下次回收不会再执行一次finalize方法了)
> 4. 稍后进行第二次标记, 然后进行回收

#### 2. 方法区回收

>  	1. 常量池回收: 系统没有一个对象引用了该字面量
>  	2. 类回收: 1.类所有实例都已被回收(没一个类的对象); 2.类的ClassLoader已经被回收; 3.类的Class对象没有被引用,没有通过反射获取的



*并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。*

*并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上*。

*吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。*

*Minor GC: 新生代GC, 发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快*

*Major GC / Full GC: 老年代GC, 发生在老年代的GC, Major GC的速度一般会比Minor GC慢10倍以上*

## 4.垃圾收集算法

#### 1. 标记-清除算法

> 步骤: 标记, 清除
>
> 优缺: 效率低; 会产生内存碎片

#### 2. 复制算法

> 将内存划分为等大的两块区域,每次只使用一块, 回收时把存活的对象复制到另一块再清除上一块
>
> 新生代普遍使用
>
> 优缺: 效率高, 但是浪费内存

#### 3. 标记-整理算法

> 步骤: 标记, 整理

#### 4. 分代收集算法

> 将java虚拟机堆按照对象存活时长分为不同的空间,采用不同的垃圾回收算法进行收集
>
> 当今普遍使用
>
> 优缺: 效率高, 但是浪费内存

## 5.垃圾收集器

![如果两个收集器之间存在连线，就说明它们可以搭配使用](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606101317354.png)

*如果两个收集器之间存在连线，就说明它们可以搭配使用*



```text
新生代收集器 : Serial收集器, ParNew 收集器, Parallel Scavenge 收集器 (都是复制算法)
老年代收集器 : Serial Old收集器(标记整理), Parallel Old收集器(标记整理), CMS收集器(标记清除)
都可以收集器 : G1收集器(复制算法+标记整理)
```





#### 1. Serial收集器

![image-20210606114804110](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606114804110.png)

> 历史最悠久的收集器, 新生代收集器, 单线程收集器, 串行收集器(串行不等于单线程,而是垃圾收集时会暂停其他工作线程: Stop The World”)
>
> 简单而高效, 是HotSpot虚拟机运行在Client模式下的默认的新生代收集器	

#### 2. ParNew 收集器

![image-20210606115048533](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606115048533.png)

> ParNew收集器就是Serial收集器的多线程版本, 新生代收集器,  串行收集器, 可以和CMS收集器（Concurrent Mark Sweep）配合工作
>
> -XX:ParallelGCThreads=n : 设置GC的工作线程数量

#### 3. Parallel Scavenge 收集器

> 新生代收集器, 多线程收集器, 并行收集器
>
> Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。
>
> 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
>
> -XX:+UseAdaptiveSizePolicy: 开关参数，打开参数后，就不需要手工指定新生代 -Xmn、-XX:SurvivorRatio 、-XX:PretenureSizeThreshold等细节参数, 虚拟机会根据系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

#### 4. Serial Old收集器

![Serial/Serial Old配合使用的工作流程图](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606152305497.png)

> Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。

#### 5. Parallel Old收集器

![Parallel Scavenge/Parallel Old收集器配合使用的流程图](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606152342231.png)

> Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。(吞吐量优先)

#### 6. CMS收集器

![image-20210606152450286](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606152450286.png)

- 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
- 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。
- 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
- 并发清除（CMS concurrent sweep）

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，应用在非常重视服务的响应速度的场景, 使用多线程和“标记-清除”算法
>
> 整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作
>
> 并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）
>
> 缺点:  对CPU资源非常敏感, 总吞吐量降低

*CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。*

*由于在垃圾收集阶段用户线程还需要运行, 无法处理浮动垃圾, 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC(启用后备*Serial Old收集器进行)的产生, 需要预留有足够的内存空间给用户线程, CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集; 可以通过-XX:CMSInitiatingOccupancyFraction设置触发CMS垃圾回收的比例 : 1.5默认是68%, 1.6默认92%*

*由于使用标记-清除算法, 会导致的空间碎片; 当无法找到足够大的连续空间分配, 会提前Full GC; 可以通过-XX:+UseCMSCompactAtFullCollection设置空间不足时是否开启碎片整理, 或者通过-XX:CMSFullGCsBeforeCompaction设置指向多少次不压缩的Full GC之后执行一次带压缩的Full GC(默认0,表示每次都带)*

#### 7. G1收集器

![image-20210606154850849](20210605001_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210606154850849.png)

- 初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。
- 并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。
- 最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
- 筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

> 多线程收集器, 并行收集器, G1可以不需要其他收集器配合就能独立管理整个GC堆
>
> G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的
>
> G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。
>
> 拥有可预测的停顿, 可以建立可预测的时间模型, 可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
>
> 为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作。检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。(上面G1的收集操作步骤是在不计算维护Remembered Set的操作情况下进行的)

## 6.GC日志 TODO



