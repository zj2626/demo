条件化简技术:

条件: sql语句中对元组进行过滤和连接的表达式, 出现在where/on/having中

条件化简技术
    1.条件下推: 把单个表相关的条件放到对单表扫描的过程中执行

    2.条件化简:
        1. having条件并入where条件中,使用and操作 (只有在语句中不存在聚集函数或groupby条件的时候才能合并) (mysql都不支持, 需要人工优化)
        2. 去除表达式中冗余的括号,减少cpu消耗 (mysql支持)
        3. 常量传递  (mysql支持)
        4. 消除死码:去掉无效的条件  (mysql支持, 返回Impossible WHERE)
        5. 表达式计算: 对条件中可求值的表达式进行计算 (mysql支持)
        6. 等式变换: 变换条件中的表达式,使得列名单独处于表达式一边而不是直接计算(能更好的利用索引) (mysql不支持, 需要人工优化)
            eg: col_1 + 1 = 2 变换为 col_1 = 1;
        7. 不等式变换: 同上,去掉不必要的重复条件 (mysql不支持, 需要人工优化)
        8. 布尔表达式变换:
            1. 谓词传递闭包: 利用传递性,设置必要条件,可以利用更多的索引,提高效率;  (mysql不支持, 需要人工优化)
                EXPLAIN  select testb.AGE from  testb, testa where  testb.AGE < 5 AND testa.AGE < testb.AGE;
                EXPLAIN  select testb.AGE from  testb, testa where  testb.AGE < 5 AND testa.AGE < testb.AGE AND testa.AGE < 5;
            2. 布尔表达式被转化为一个等价的合取范式(CNF); (mysql支持, and操作符的条件是可交换的,并且谁连接在前,则优化之后谁的条件就在前)
            3. 索引利用: or的子项可以利用索引,优先判断连接表涉及的带有索引的条件; (mysql支持)
        9. is null: (mysql支持优化)
        10. 基于成本:  查询成本=I/O成本+CPU成本
            一个查询可以有不同的执行方案，可以选择某个索引进行查询，也可以选择全表扫描，查询优化器会选择其中成本最低的方案去执行查询
            1. I/O成本: InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为I/O成本
            2. CPU成本: 读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU成本。
            [InnoDB存储引擎规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。]

            计算过程
                对于sql语句:  EXPLAIN select * from testd where id > 10001 and name like '2%' and  age > 450; 可以使用的是聚簇索引或者name上的索引或者age上的索引
                ### 查询优化结果见: @see 测试查询成本.txt
                一. 计算全表扫描的代价 (聚簇索引页数*1+行数*0.2)
                    1. 通过: SHOW TABLE STATUS LIKE 'testd'; 获取表testd记录条数(Rows)=48162 和 占用空间字节数(Data_length)=2637824
                       通过: SHOW GLOBAL STATUS like 'Innodb_page_size'; 获取mysql的页大小=16384 也就是 16k
                        # Rows: 对于使用MyISAM存储引擎的表来说，该值是准确的，对于使用InnoDB存储引擎的表来说，该值是一个估计值。
                        # Data_length: 使用MyISAM存储引擎的表来说，该值就是数据文件的大小，对于使用InnoDB存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小(相当于聚簇索引页面数*每页大小)
                    2. 得到Data_length, mysql的默认页大小为16k(绝大多数处理器上的内存页的默认大小都是4KB),可得出聚簇索引的页面数量为 Data_length除16除1024 = 2637824/16/1024=161 (页)
                    3. 通过页数和记录条数计算全表扫描成本:
                        I/O成本: 161 * 1   = 161
                        CUP成本: 48162*0.2 = 9632.4
                        总成本:  161+9632.4 = 9793.4
                二. 计算聚簇索引(PRIMARY)代价 (预估根据对应的where条件在主键索引B+树中存在多少条符合条件的记录)
                    1. 找到最左区间所在页(第一条记录所在), 找到最右区间所在页(最后一条记录所在)
                    2. 通过查询优化器日志可得 访问区间[10001 < id]数据有24081行 页数有 24081*30/16/1024=44.09 (页)
                    3. 如果两页相隔不大于10个页, 则计算其中记录条数, 否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量(页面数量通过计算它们父节点中对应的目录项记录之间隔着几条记录)
                        I/O成本: 44.09 * 1   = 44.09
                        CUP成本: 24081*0.2 = 4816.2
                        总成本:  44.09+4816.2 = 4860.29
                三. 计算索引(ONLY_AGE)代价
                    1. 找到最左区间所在页(第一条记录所在), 找到最右区间所在页(最后一条记录所在)
                    2. 通过查询优化器日志可得 访问区间[450 < age]数据有4672行 页数有 4672*30/16/1024=44.09 (页)
                    3. 如果两页相隔不大于10个页, 则计算其中记录条数, 否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以区间最左记录和区间最右记录之间的页面数量(页面数量通过计算它们父节点中对应的目录项记录之间隔着几条记录)
                        I/O成本: 44.09 * 1   = 44.09
                        CUP成本: 24081*0.2 = 4816.2
                        总成本:  44.09+4816.2 = 4860.29
                四. 计算索引(NAME_SEX)代价
                五. 计算索引(ONLY_NAME)代价
