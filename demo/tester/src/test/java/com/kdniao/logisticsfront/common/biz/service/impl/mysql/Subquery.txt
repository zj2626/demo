查询优化:

子查询优化:
    分类:
        1.子查询在目标列位置:
            要求:子查询必须为标量子查询
        2.子查询在From子句位置:
            要求:子查询不能为相关子查询; 非相关子查询必须指定别名
            优化:对于非相关子查询,可以上拉子查询到父查询,变为多表连接查询,再针对多表连接进行优化
        3.子查询在Where子句位置:
            要求: 1.对于等值操作:子查询必须为标量子查询
                  2.对于使用谓词的操作(IN,BETWEEN,EXISTS):优化方式不尽相同
        4.子查询在Join/On子句位置:

        5.子查询在GroupBy子句位置: 没意义
        6.子查询在OrderBy子句位置: 没意义

    方式:
        1.子查询合并: 多个子查询合并成为一个子查询, 可以把多次表扫描,多次连接变成一次
        2.子查询展开(子查询反嵌套,子查询上拉):把子查询重写为等价的多表连接操作,使层次尽可能减少
            (IN/ANY/SOME/ALL/EXISTS依据情况转换为半连接(semi-jion),普通类型子查询消除)
        3.聚合子查询消除: 部分数据库系统支持标量聚集子查询(包含聚合函数的子查询)消除

    Mysql支持优化的子查询
        简单的子查询
            1.简单select查询中的子查询
            2.带有distinct,orderby,limit操作的简单select查询中的子查询
    Mysql不支持优化的子查询
        1.带有UNION操作
        2.带有GROUPBY,HAVING,聚合函数
        3.使用ORDERBY中带有LIMIT(同时)
        4.内表外表个数超过mysql的最大连接数(63张)

    Mysql对子查询优化技术的支持
        1.子查询合并--不支持
        2.子查询展开--有限支持
        3.聚合子查询消除--不支持

    Mysql支持对哪些类型的子查询进行优化
        1.不支持对EXISTS类型的子查询的优化 (不支持是指不支持采用子查询上拉的技术进行优化;对于EXISTS,mysql不支持)
        2.不支持对NOT EXISTS类型的子查询的优化
        3.支持IN:
            1.相关子查询:  子查询物化之后,进一步优化为半连接
            2.非相关子查询:
        4.支持一定的NOT IN: 子查询物化,但是不会子查询上拉
        5.ANY
        6.SOME
        7.支持ALL:
            1. > ALL, >= ALL: 子查询被转化为MAX运算,但是不会子查询上拉
            2. = ALL: 子查询被转化为EXISTS操作,但是不会子查询上拉
            1. < ALL, <= ALL: 子查询被转化为MIN运算,但是不会子查询上拉



示例:
1.子查询展开
    mysql> EXPLAIN SELECT
        testb.ID,
        testb.AGE
    FROM
        testb,
        ( SELECT ID, AGE FROM testa WHERE testa.AGE < 10000 ) test1
    WHERE
        test1.AGE = testb.AGE;
    +----+-------------+-------+------------+-------+---------------+-------+---------+----------------+------+----------+--------------------------+
    | id | select_type | table | partitions | type  | possible_keys | key   | key_len | ref            | rows | filtered | Extra                    |
    +----+-------------+-------+------------+-------+---------------+-------+---------+----------------+------+----------+--------------------------+
    |  1 | SIMPLE      | testa | NULL       | index | A_AGE         | A_AGE | 5       | NULL           | 4261 |   100.00 | Using where; Using index |
    |  1 | SIMPLE      | testb | NULL       | ref   | B_AGE         | B_AGE | 5       | test.testa.AGE |    3 |   100.00 | Using index              |
    +----+-------------+-------+------------+-------+---------------+-------+---------+----------------+------+----------+--------------------------+
    2 rows in set (0.08 sec)

    mysql> show warnings;
    +-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Level | Code | Message                                                                                                                                                                                                          |
    +-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Note  | 1003 | /* select#1 */ select `test`.`testb`.`ID` AS `ID`,`test`.`testb`.`AGE` AS `AGE` from `test`.`testb` join `test`.`testa` where ((`test`.`testb`.`AGE` = `test`.`testa`.`AGE`) and (`test`.`testa`.`AGE` < 10000)) |
    +-------+------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    1 row in set (0.07 sec)

